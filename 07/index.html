<!DOCTYPE html>
<html lang="ja">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<meta name="robots" content="noindex">
	<title>【js_07】ユーザーアクションの取り扱い</title>
	<!--css-->
	<link rel="stylesheet" href="../css/base.css" media="all">
	<!--js-->
	<script src="https://code.jquery.com/jquery-3.2.1.min.js"></script>
</head>

<body style="	height: auto!important; overflow: auto!important;">
<h1>【Chapter7】ユーザーアクションの取り扱い【113〜134】</h1>
<section>
<h2><b>113</b>イベントについて知る</h2>
<ul>
	<li>イベントを発生させるオブジェクトを「イベントターゲット」という</li>
	<li>イベントが発生したときの処理を「イベントリスナー」という</li>
	<li>イベントターゲット、イベント、イベントリスナーはaddEventListener()メソッドで関連づける</li>
</ul>
</section><!-- section -->

<section>
<h2><b>114</b>ユーザーの操作が起こった時に処理を行う</h2>
<table>
	<tr>
		<th>メソッド</th>
		<th>意味</th>
		<th>戻り値</th>
	</tr>
	<tr>
		<td>イベントターゲット.addEventListener(イベント名, リスナー, [オプション※省略可])</td>
		<td>イベントリスナーの設定</td>
		<td>なし</td>
	</tr>
</table>
<ul>
	<li>イベント発生時に呼び出す関数を指定できる</li>
</ul>
<pre><code>const button = document.querySelector('.button');

//アロー関数を使う方法
button.addEventListener('click', () => {
	console.log('クリック');
})

//function宣言を使う方法
button.addEventListener('click', function() {
	console.log('クリック');
})

//関数名を指定する方法
button.addEventListener('click', onClickButton);
function onClickButton() {
	console.log('クリック');
}
</code></pre>
<h4>SAMPLE #114<b>イベントの情報を取得する</b></h4>
<ul>
	<li>引数としてイベントの情報（イベントオブジェクト）を受け取ることができる</li>
	<li>イベントオブジェクトには、イベントが発生した要素の参照や押されたキーなどの情報が含まれている</li>
</ul>
<pre><code>
button.addEventListener('click', (event) => {
	//イベントの情報を出力する
	console.log(event);
	//クリックされたボタン要素が出力される
	console.log(event.target);
});
</code></pre>
<div class="btn" id="btn114">SAMPLE #114</div>
</section><!-- section -->

<section>
<h2><b>115</b>イベントリスナーを一度だけ呼び出す</h2>
<table>
	<tr>
		<th>オプション</th>
		<th>意味</th>
		<th>型</th>
	</tr>
	<tr>
		<td>capture</td>
		<td>キャプチャーフェーズで取得するか</td>
		<td>真偽値</td>
	</tr>
	<tr>
		<td>once</td>
		<td>リスナーの呼び出しを一回のみにするか</td>
		<td>真偽値</td>
	</tr>
	<tr>
		<td>passive</td>
		<td>パッシブイベントかどうか</td>
		<td>真偽値</td>
	</tr>
</table>
<ul>
	<li>addEventListener()の第3引数にオプションを指定できる</li>
</ul>
<h4>SAMPLE #115<b>一度だけイベントを受け付ける場合</b></h4>
<pre><code>const option = {
	once: true
};
//オプションなし
document.querySelector('#btn115').addEventListener('click', onClickButton);
//オプションあり
document.querySelector('#btn115once').addEventListener('click', onClickButton, option);

function onClickButton() {
	alert('ボタンが押されました');
}
</code></pre>
<div class="btn" id="btn115">once設定なし</div>
<div class="btn" id="btn115once">once設定あり</div>
</section><!-- section -->

<section>
<h2><b>116</b>設定したイベントリスナーを削除する</h2>
<table>
	<tr>
		<th>メソッド</th>
		<th>意味</th>
		<th>戻り値</th>
	</tr>
	<tr>
		<td>イベントターゲット.removeEventListener(イベント名, リスナー, [オプション※省略可])</td>
		<td>イベントリスナーの削除</td>
		<td>なし</td>
	</tr>
</table>
<ul>
	<li>removeEventListener()メソッドを使うとイベントの監視を取りやめる</li>
	<li>関数名を指定する（アロー関数は不可）</li>
	<li>addEventListener()の引数と（オプションを含めて）同じ引数を指定する</li>
</ul>
<pre><code>const box = document.querySelector('.box');
box.addEventListener('click', onClickButton);

//3秒後にリスナー関数を削除する
setTimeout(() => {
	box.removeEventListener('click', onClickButton);
}, 3000);

function onClickButton() {
	alert('boxがクリックされました');
}</code></pre>
</section><!-- section -->

<section>
<h2><b>117</b>ページが表示されたときに処理をする</h2>
<table>
	<tr>
		<th>イベント名</th>
		<th>発生タイミング</th>
	</tr>
	<tr>
		<td>DOMContentLoaded</td>
		<td>HTMLドキュメントの解析完了時</td>
	</tr>
	<tr>
		<td>load</td>
		<td>全リソースの読み込み完了時</td>
	</tr>
</table>
<h3>DOMContentLoaded</h3>
<ul>
	<li>jsでDOMを操作できるのは、HTMLの読み込みと解析が完了したタイミング</li>
	<li>このタイミングで発生するのが、DOMContentLoadedイベント</li>
</ul>
<h3>load</h3>
<ul>
	<li>ページ内の全リソースの読み込み完了時に発生するのが、loadイベント</li>
</ul>
<h4>SAMPLE #117<b>DOMContentLoaded、load</b></h4>
<pre><code>window.addEventListener('DOMContentLoaded', () => {
	//sectionの数を取得
	const sectionNum = document.querySelectorAll('section').length;
	console.log(`sectionの数は${sectionNum}`);
});

window.addEventListener('load', () => {
	const sectionNum = document.querySelectorAll('section').length;
	console.log(`sectionの数は${sectionNum}`);
});</code></pre>
<h3>scriptタグのdefer属性とDOMContentLoaded</h3>
<ul>
	<li>scriptタグにdefer属性を設定すると、HTMLの解析終了後に実行される（DOMContentLoadedイベントの発生前）</li>
	<li>したがってdefer属性を設定している場合、DOMContentLoadedイベントは不要といえる</li>
</ul>
</section><!-- section -->

<section>
<h2><b>118</b>クリック時に処理をする</h2>
<table>
	<tr>
		<th>イベント名</th>
		<th>発生タイミング</th>
	</tr>
	<tr>
		<td>click</td>
		<td>要素のクリック時</td>
	</tr>
</table>
<ul>
	<li>clickイベントは要素のクリック時、タップ時に発生する</li>
</ul>
<h4>SAMPLE #118<b>click</b></h4>
<pre><code>document.querySelector('#btn118').addEventListener('click', () => {
	alert('ボタンがクリックされました');
})</code></pre>
<p class="btn" id="btn118">SAMPLE #118</p>
</section><!-- section -->

<section>
<h2><b>119</b>マウスを押したときや動かしたときに処理をする</h2>
<table>
	<tr>
		<th>イベント名</th>
		<th>発生タイミング</th>
	</tr>
	<tr>
		<td>mousedown</td>
		<td>マウスボタンを押したとき</td>
	</tr>
	<tr>
		<td>mouseup</td>
		<td>マウスボタンを離したとき</td>
	</tr>
	<tr>
		<td>mousemove</td>
		<td>マウスを動かしたとき</td>
	</tr>
</table>
<h4>SAMPLE #119<b>マウス操作イベント</b></h4>
<pre><code>const logArea = document.querySelector('.logArea');

logArea.addEventListener('mousedown', () => {
	logArea.innerHTML = 'マウスボタンを押した';
});
logArea.addEventListener('mouseup', () => {
	logArea.innerHTML = 'マウスボタンを離した';
});
logArea.addEventListener('mousemove', () => {
	logArea.innerHTML = 'マウスを動かした';
});</code></pre>
<div class="logArea" style="background: rgba(255,255,255,0.5); text-align: center; padding: 100px;">操作対象エリア</div>
</section><!-- section -->

<section>
<h2><b>120</b>マウスオーバー時に処理をする</h2>
<table>
	<tr>
		<th>イベント名</th>
		<th>発生タイミング</th>
	</tr>
	<tr>
		<td>mouseenter</td>
		<td>ポインティングデバイスが要素上に乗ったとき</td>
	</tr>
	<tr>
		<td>mouseleave</td>
		<td>ポインティングデバイスが要素上から離れたとき</td>
	</tr>
</table>
<h4>SAMPLE #120<b>マウスオーバーイベント</b></h4>
<pre><code>const logArea2 = document.querySelector('.logArea2');
const logArea2Child = document.querySelector('.logArea2_child');

logArea2.addEventListener('mouseenter', () => {
	console.log('2マウスが乗った');
});
logArea2Child.addEventListener('mouseenter', () => {
	console.log('2Childマウスが乗った');
});
logArea2.addEventListener('mouseleave', () => {
	console.log('2マウスが離れた');
});
logArea2Child.addEventListener('mouseleave', () => {
	console.log('2Childマウスが離れた');
});</code></pre>
<div class="logArea2" style="background: rgba(255,255,255,0.5); text-align: center; padding: 0 100px;">
	<p>操作対象エリア「2」</p>
	<div class="logArea2_child" style="background: rgba(255,255,255,0.5); text-align: center; padding: 100px;">
		<p>操作対象エリア「2Child」</p>
	</div>
</div>
</section><!-- section -->

<section>
<h2><b>121</b>マウスオーバー時に処理をする（バブリングあり）</h2>
<table>
	<tr>
		<th>イベント名</th>
		<th>発生タイミング</th>
	</tr>
	<tr>
		<td>mouseover</td>
		<td>ポインティングデバイスが要素上に乗ったとき（バブリングあり）</td>
	</tr>
	<tr>
		<td>mouseout</td>
		<td>ポインティングデバイスが要素上から離れたとき（バブリングあり）</td>
	</tr>
</table>
<ul>
	<li>mouseenter、mouseleaveと異なりイベントがバブリングする</li>
	<li>バブリングとは、ある要素で発生したイベントが親要素・先祖要素に伝わること</li>
	<li>親要素・子要素でイベントリスナーを設定していた場合、子要素で発生したベントが親要素にも発生し、親要素のイベントリスナーが実行される</li>
</ul>
<h4>SAMPLE #120<b>マウスオーバーイベント（バブリングあり）</b></h4>
<pre><code>const logArea3 = document.querySelector('.logArea3');
const logArea3Child = document.querySelector('.logArea3_child');

logArea3.addEventListener('mouseover', () => {
	console.log('3マウスが乗った');
});
logArea3Child.addEventListener('mouseover', () => {
	console.log('3Childマウスが乗った');
});
logArea3.addEventListener('mouseout', () => {
	console.log('3マウスが離れた');
});
logArea3Child.addEventListener('mouseout', () => {
	console.log('3Childマウスが離れた');
});</code></pre>
<div class="logArea3" style="background: rgba(255,255,255,0.5); text-align: center; padding: 0 100px;">
	<p>操作対象エリア「3」</p>
	<div class="logArea3_child" style="background: rgba(255,255,255,0.5); text-align: center; padding: 100px;">
		<p>操作対象エリア「3Child」</p>
	</div>
</div>
</section><!-- section -->

<section>
<h2><b>122</b>マウス操作時の座標を取得する</h2>
<table>
	<tr>
		<th>プロパティ</th>
		<th>内容</th>
		<th>型</th>
	</tr>
	<tr>
		<td>event.clientX</td>
		<td>ブラウザ左上を基準としたX座標</td>
		<td>数値</td>
	</tr>
	<tr>
		<td>event.clientY</td>
		<td>ブラウザ左上を基準としたY座標</td>
		<td>数値</td>
	</tr>
	<tr>
		<td>event.offsetX</td>
		<td>要素左上を基準としたX座標</td>
		<td>数値</td>
	</tr>
	<tr>
		<td>event.offsetY</td>
		<td>要素左上を基準としたY座標</td>
		<td>数値</td>
	</tr>
	<tr>
		<td>event.pageX</td>
		<td>ページ左上を基準としたX座標</td>
		<td>数値</td>
	</tr>
	<tr>
		<td>event.pageY</td>
		<td>ページ左上を基準としたY座標</td>
		<td>数値</td>
	</tr>
	<tr>
		<td>event.screenX</td>
		<td>デバイス左上を基準としたX座標</td>
		<td>数値</td>
	</tr>
	<tr>
		<td>event.screenY</td>
		<td>デバイス左上を基準としたY座標</td>
		<td>数値</td>
	</tr>
</table>
<ul>
	<li>clickやmousemoveなどマウス操作イベントが発生した際のイベントはMouseEventオブジェクト</li>
	<li>MouseEventオブジェクトにはイベント発生時の座標情報が含まれている</li>
	<li>pageX、pageYはページスクロール量が加味される</li>
</ul>
<h3>マウス移動時の座標を出力</h3>
<pre><code>targetBox.addEventListener('mousemove', (event) => {
	console.log(event.clientX, event.clientY);
});</code></pre>
<h4>SAMPLE #122<b>マウスに合わせて要素を動かす</b></h4>
<pre><code>const chara = document.querySelector('.chara');
const charaArea = document.querySelector('.charaArea');

//マウスを押すとキャラの移動開始
charaArea.addEventListener('mousedown', () => {
	//キャラを動かす
	charaArea.addEventListener('mousemove', onMouseMove);
	//マウスを離したらキャラの移動終了
	charaArea.addEventListener('mouseup', () => {
		charaArea.removeEventListener('mousemove', onMouseMove);
	});
});

function onMouseMove(event) {
	chara.style.left = `${event.clientX - 180}px`;
	chara.style.top = `${event.clientY - 500}px`;
}</code></pre>
<h3>マウスをドラッグ</h3>
<div class="charaArea" style="background: rgba(255,255,255,0.5); text-align: center; padding: 0 100px; position: relative; height: 400px;">
	<div class="chara" style="display: inline-block; position: absolute; top: 100px; left: 100px;"><img src="../img/chara.png" alt=""></div>
</div>
</section><!-- section -->

<section>
<h2><b>123</b>スクロール時に処理をする</h2>
<table>
	<tr>
		<th>イベント名</th>
		<th>発生タイミング</th>
	</tr>
	<tr>
		<td>scroll</td>
		<td>対象の要素（主にwindow）がスクロールしたとき</td>
	</tr>
</table>
<ul>
	<li>ウィンドウ上のスクロール量は、window.scrollY（縦方向）window.scrollX（横方向）で取得できる</li>
</ul>
<h4>SAMPLE #123<b>スクロールで座標を出力</b></h4>
<pre><code></code></pre>
<div class="scrollBox" style="display: inline-block;position: fixed;top: 20px;right: 0;background: rgba(255,255,255,0.5);padding: 10px 20px;"></div>
</section><!-- section -->

<section>
<h2><b>124</b>テキスト選択時に処理する</h2>
<table>
	<tr>
		<th>イベント名</th>
		<th>発生タイミング</th>
	</tr>
	<tr>
		<td>selectstart</td>
		<td>テキストが選択されたとき</td>
	</tr>
</table>
<h4>SAMPLE #124<b>選択した文字列を表示する</b></h4>
<pre><code>const balloon = document.querySelector('#balloon');
const paragraph = document.querySelector('.paragraph');

paragraph.addEventListener('selectstart', () => {
	//マウスを離したとき
	paragraph.addEventListener('mouseup', (event) => {
		//選択された文字列を取得
		const selectionCharacters = window.getSelection().toString();
		if (selectionCharacters.length > 0) {
			balloon.innerHTML = selectionCharacters;
			balloon.classList.add('on');
			balloon.style.left = `${event.clientX - 10}px`;
			balloon.style.top = `${event.clientY - 440}px`;
		} else {
			//吹き出しを閉じる
			removePopup();
		}
	},
	{
		once: true
	});
});

//吹き出しを閉じる
balloon.addEventListener('click', removePopup);

function removePopup() {
	balloon.classList.remove('on');
}</code></pre>
<ul>
	<li>window.getSelection()は選択範囲を返す処理</li>
	<li>toString()を末尾に付与することで選択中の文字列を返す</li>
</ul>
<div class="wrap" style="border: solid 1px #fff; text-align: center; padding: 30px; position: relative;">
	<p class="paragraph">あうｇはういｆがｓｈｄふぁうｓｄさんｆｋぁｓｋｌｆばｓｆｋぁｓふぃあ<br>23473ndglkdsｄｓｇｌｄｋｓんｇｌ<br>ふぁそｓｄｎ6786fklGSFGSFLSKF</p>
	<div id="balloon"></div>
</div>
<style>
#balloon {
	opacity: 0;
	position: absolute;
	background: #faff68;
	color: #11131a;
	padding: 3px 6px;
	border-radius: 5px;
	font-weight: bold;
	cursor: pointer;
}
#balloon.on {
	opacity: 1;
}
</style>
</section><!-- section -->

<section>
<h2><b>114</b></h2>
<pre><code></code></pre>
</section><!-- section -->

<section>
<h2><b>114</b></h2>
<pre><code></code></pre>
</section><!-- section -->

<section>
<h2><b>114</b></h2>
<pre><code></code></pre>
</section><!-- section -->

<section>
<h2><b>114</b></h2>
<pre><code></code></pre>
</section><!-- section -->

<section>
<h2><b>114</b></h2>
<pre><code></code></pre>
</section><!-- section -->

<section>
<h2><b>114</b></h2>
<pre><code></code></pre>
</section><!-- section -->

<section>
<h2><b>114</b></h2>
<pre><code></code></pre>
</section><!-- section -->

<section>
<h2><b>114</b></h2>
<pre><code></code></pre>
</section><!-- section -->

<section>
<h2><b>114</b></h2>
<pre><code></code></pre>
</section><!-- section -->

<section>
<h2><b>114</b></h2>
<pre><code></code></pre>
</section><!-- section -->

<section>
<h2><b>114</b></h2>
<pre><code></code></pre>
</section><!-- section -->

<section>
<h2><b>114</b></h2>
<pre><code></code></pre>
</section><!-- section -->

<section>
<h2><b>114</b></h2>
<pre><code></code></pre>
</section><!-- section -->

<section>
<h2><b>114</b></h2>
<pre><code></code></pre>
</section><!-- section -->


	<script src="../js/07.js"></script>
</body>

</html>